import socket, threading
from traceback import print_exc
from questionary import prompt
from abc import ABC, abstractmethod
from concurrent.futures import ThreadPoolExecutor, as_completed
from ..models.Tool import Tool

class PortScanner(ABC):
    @abstractmethod
    def check_port(self, domain, port, timeout):
        pass
    
class TCPPortScanner(PortScanner):
    def check_port(self, domain, port, timeout):
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        sock.settimeout(timeout)
        try:
            sock.connect((domain, port))
            try:
                service_name = socket.getservbyport(port, 'tcp')
            except OSError:
                service_name = 'Unknown service'

            try:
                sock.sendall(b'\n')
                banner = sock.recv(1024).decode().strip()
            except:
                banner = 'No banner'

            return (port, service_name, banner)
        except socket.timeout:
            return None
        except ConnectionRefusedError:
            return None
        except:
            print_exc()
            return None
        finally:
            sock.close()

class PortScan(Tool):
    def __init__(self):
        super().__init__(name="Port Scan", description="Scan open ports on a target machine")
        self.domain = None
        self.timeout = 2.0
        self.port_range = (1024, 65535)
        self.threadcount = 10
        self._lock = threading.Lock()
        self._ports_active = []
        self._known_ports = set()
        self.port_scanner = TCPPortScanner()
        
    def _scan_port(self, port):
        result = self.port_scanner.check_port(self.domain, port, self.timeout)
        if result:
            port, service_name, banner = result
            with self._lock:
                if port not in self._known_ports:
                    self._ports_active.append(result)
                    self._known_ports.add(port)
                    print(f"\033[38;5;46m[*] Found active port \033[38;5;91m{port}\033[0m (\033[38;5;51m{service_name}\033[38;5;255m - \033[38;5;4m{banner}\033[0m)")

        
    def run(self):
        try:
            answers = prompt([
                {
                    'type': 'input',
                    'name': 'domain',
                    'message': 'Enter the domain to scan:'
                },
                {
                    'type': 'input',
                    'name': 'port_s',
                    'message': 'Enter the start port:'
                },
                {
                    'type': 'input',
                    'name': 'port_e',
                    'message': 'Enter the end port:'
                }
            ])
            
            self.domain = answers['domain']
            port_s = int(answers['port_s'] or 1)
            port_e = int(answers['port_e'] or 65535)
            self.port_range = (port_s, port_e)
            
            with ThreadPoolExecutor(max_workers=self.threadcount) as executor:
                future_to_port = {executor.submit(self._scan_port, port): port for port in range(port_s, port_e + 1)}
                for future in as_completed(future_to_port):
                    port = future_to_port[future]
                    try:
                        future.result()
                    except Exception as exc:
                        print(f'Port {port} generated an exception: {exc}')
            
            print("\033[38;5;196m[!]\033[38;5;255m Port scanning completed.")
        except:
            print_exc()
        

if __name__ == '__main__':
    tool = PortScan()
    tool.run()